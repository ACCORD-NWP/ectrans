MODULE TPM_FFTW
!   Author.
!   -------
!     George Mozdzynski
!
!   Modifications.
!   -------------- 
!     Original      October 2014

USE, INTRINSIC :: ISO_C_BINDING

USE PARKIND1        ,ONLY: JPIB, JPIM, JPRB
USE MPL_MODULE      ,ONLY : MPL_MYRANK
USE ABORT_TRANS_MOD ,ONLY : ABORT_TRANS

IMPLICIT NONE

SAVE

#include "fftw3.f03.h"

PRIVATE
PUBLIC CREATE_PLAN_FFTW, DESTROY_PLAN_FFTW, DESTROY_PLANS_FFTW, INIT_PLANS_FFTW, &
      & FFTW_RESOL, TW

TYPE FFTW_TYPE
  INTEGER(KIND=JPIM),ALLOCATABLE :: N_PLANS(:)
  TYPE(FFTW_PLAN),POINTER :: FFTW_PLANS(:)
  INTEGER(KIND=JPIM) :: N_MAX=0         ! maximum number of latitudes
  INTEGER(KIND=JPIM) :: N_MAX_PLANS=4   ! maximum number of plans for each active latitude
  LOGICAL            :: LFFTW=.FALSE. 
END TYPE FFTW_TYPE


TYPE FFTW_PLAN
  INTEGER(KIND=JPIM) :: NPLAN_ID=123456
  INTEGER(KIND=JPIB) :: NPLAN
  INTEGER(KIND=JPIM) :: NLOT
  INTEGER(KIND=JPIM) :: NTYPE
  TYPE(FFTW_PLAN),POINTER :: NEXT_PLAN => NULL()
END TYPE FFTW_PLAN

TYPE(FFTW_TYPE),ALLOCATABLE,TARGET :: FFTW_RESOL(:)
TYPE(FFTW_TYPE),POINTER     :: TW



! ------------------------------------------------------------------
CONTAINS
! ------------------------------------------------------------------


SUBROUTINE INIT_PLANS_FFTW(KDLON)
INTEGER(KIND=JPIM),INTENT(IN) :: KDLON

TW%N_MAX=KDLON
ALLOCATE(TW%FFTW_PLANS(TW%N_MAX))
ALLOCATE(TW%N_PLANS(TW%N_MAX))
TW%N_PLANS(:)=0
RETURN  
END SUBROUTINE INIT_PLANS_FFTW


SUBROUTINE CREATE_PLAN_FFTW(KPLAN,KTYPE,KN,KLOT)
INTEGER(KIND=JPIB),INTENT(OUT) :: KPLAN
INTEGER(KIND=JPIM),INTENT(IN) :: KTYPE,KN,KLOT

INTEGER(KIND=JPIB) :: IPLAN
INTEGER(KIND=JPIM) :: IRANK, ISTRIDE
INTEGER(KIND=JPIM) :: JL, JN
INTEGER(KIND=JPIM) :: IRDIST,ICDIST,IN(1),IEMBED(1)
REAL(KIND=JPRB), POINTER :: ZDUM(:)
TYPE(C_PTR) :: ZDUMP
LOGICAL :: LLFOUND
LOGICAL :: LLRESTRICT_PLANS=.TRUE.
TYPE(FFTW_PLAN),POINTER :: CURR_FFTW_PLAN,START_FFTW_PLAN

IF( KN > TW%N_MAX )THEN
  CALL ABORT_TRANS('CREATE_PLAN_FFTW: KN > N_MAX THAT WAS INITIALISED IN INIT_PLANS_FFTW')
ENDIF

IRANK=1
ISTRIDE=1
IN(1)=KN
IEMBED(1)=IN(1)
ICDIST=KN/2+1
IRDIST=ICDIST*2

!$OMP CRITICAL
LLFOUND=.FALSE.
IF( TW%FFTW_PLANS(KN)%NPLAN_ID /= 123456 )THEN
  WRITE(*,'("CREATE_PLAN_FFTW.1: PLAN_ID=",I10)')TW%FFTW_PLANS(KN)%NPLAN_ID
  CALL ABORT_TRANS('CREATE_PLAN_FFTW.1: NPLAN_ID /= 123456')
ENDIF
CURR_FFTW_PLAN=>TW%FFTW_PLANS(KN)
IF( CURR_FFTW_PLAN%NPLAN_ID /= 123456 )THEN
  WRITE(*,'("CREATE_PLAN_FFTW.2: PLAN_ID=",I10)')CURR_FFTW_PLAN%NPLAN_ID
  CALL ABORT_TRANS('CREATE_PLAN_FFTW.2: NPLAN_ID /= 123456')
ENDIF
! search for plan in existing plans
DO JL=1,TW%N_PLANS(KN)
  IF( KLOT == CURR_FFTW_PLAN%NLOT .AND. KTYPE == CURR_FFTW_PLAN%NTYPE )THEN
    LLFOUND=.TRUE.
    IPLAN=CURR_FFTW_PLAN%NPLAN
    EXIT
  ELSEIF( JL /= TW%N_PLANS(KN) )THEN
    CURR_FFTW_PLAN=>CURR_FFTW_PLAN%NEXT_PLAN
    IF( CURR_FFTW_PLAN%NPLAN_ID /= 123456 )THEN
      WRITE(*,'("CREATE_PLAN_FFTW.3: PLAN_ID=",I10)')CURR_FFTW_PLAN%NPLAN_ID
      CALL ABORT_TRANS('CREATE_PLAN_FFTW.3: NPLAN_ID /= 123456')
    ENDIF
  ENDIF
ENDDO
IF( .NOT.LLFOUND )THEN
#ifdef WITH_FFTW
  IF( LLRESTRICT_PLANS )THEN
    IF( TW%N_PLANS(KN) == TW%N_MAX_PLANS )THEN
      ! destroy the plan at the start of the list
!     WRITE(*,'("CREATE_PLAN_FFTW: BEG: DESTROYING A PLAN AT THE START OF THE LIST")')
      CALL DFFTW_DESTROY_PLAN(TW%FFTW_PLANS(KN)%NPLAN)
      TW%FFTW_PLANS(KN)%NPLAN_ID=999999
      START_FFTW_PLAN=>TW%FFTW_PLANS(KN)
      TW%FFTW_PLANS(KN)=TW%FFTW_PLANS(KN)%NEXT_PLAN
      ! DEALLOCATE(START_FFTW_PLAN)
      TW%N_PLANS(KN)=TW%N_PLANS(KN)-1
!     WRITE(*,'("CREATE_PLAN_FFTW: END: DESTROYING A PLAN AT THE START OF THE LIST")')
    ENDIF
  ENDIF
  ZDUMP=FFTW_ALLOC_COMPLEX(INT(1,C_SIZE_T))
  CALL C_F_POINTER(ZDUMP,ZDUM,[2])
  IF( KTYPE==1 )THEN
    CALL DFFTW_PLAN_MANY_DFT_C2R(IPLAN,IRANK,IN,KLOT,ZDUM,IEMBED,ISTRIDE,ICDIST,&
      & ZDUM,IEMBED,ISTRIDE,IRDIST,FFTW_ESTIMATE+FFTW_NO_SIMD)
  ELSEIF( KTYPE==-1 )THEN
    CALL DFFTW_PLAN_MANY_DFT_R2C(IPLAN,IRANK,IN,KLOT,ZDUM,IEMBED,ISTRIDE,IRDIST,&
      & ZDUM,IEMBED,ISTRIDE,ICDIST,FFTW_ESTIMATE+FFTW_NO_SIMD)
  ELSE
    CALL ABORT_TRANS('FFTW_PLAN: INVALID KTYPE')
  ENDIF
  CALL FFTW_FREE(ZDUMP)
#else
  CALL ABORT_TRANS('CREATE_PLAN_FFTW:NEEDS CPP MACRO WITH_FFTW')
#endif
  KPLAN=IPLAN
  TW%N_PLANS(KN)=TW%N_PLANS(KN)+1
  IF( TW%N_PLANS(KN) /= 1 )THEN
    ALLOCATE(CURR_FFTW_PLAN%NEXT_PLAN)
    CURR_FFTW_PLAN=>CURR_FFTW_PLAN%NEXT_PLAN
  ENDIF
  IF( CURR_FFTW_PLAN%NPLAN_ID /= 123456 )THEN
    WRITE(*,'("CREATE_PLAN_FFTW.4: PLAN_ID=",I10)')CURR_FFTW_PLAN%NPLAN_ID
    CALL ABORT_TRANS('CREATE_PLAN_FFTW.4: NPLAN_ID /= 123456')
  ENDIF
  CURR_FFTW_PLAN%NPLAN=IPLAN
  CURR_FFTW_PLAN%NLOT=KLOT
  CURR_FFTW_PLAN%NTYPE=KTYPE
  CURR_FFTW_PLAN%NEXT_PLAN=>NULL()
! write(*,'("CREATE_PLAN_FFTW: KN=",I5," NPLANS=",I3," KLOT=",I6," KTYPE=",I2,&
!  & " NEW IPLAN=",Z16)')KN,TW%N_PLANS(KN),KLOT,KTYPE,IPLAN
ELSE
  KPLAN=IPLAN
! write(*,'("CREATE_PLAN_FFTW: KN=",I5," NPLANS=",I3," KLOT=",I6," KTYPE=",I2,&
!  & " CUR IPLAN=",Z16)')KN,TW%N_PLANS(KN),KLOT,KTYPE,IPLAN
ENDIF
!$OMP END CRITICAL

RETURN
END SUBROUTINE CREATE_PLAN_FFTW


SUBROUTINE DESTROY_PLAN_FFTW(KPLAN)
INTEGER(KIND=JPIB),INTENT(IN) :: KPLAN
#ifdef WITH_FFTW
!$OMP CRITICAL
CALL DFFTW_DESTROY_PLAN(KPLAN)
!$OMP END CRITICAL
#else
CALL ABORT_TRANS('DESTROY_PLAN_FFTW:NEEDS CPP MACRO WITH_FFTW')
#endif
RETURN
END SUBROUTINE DESTROY_PLAN_FFTW


SUBROUTINE DESTROY_PLANS_FFTW
INTEGER(KIND=JPIM) :: JL, JN
TYPE(FFTW_PLAN),POINTER :: CURR_FFTW_PLAN
DO JN=1,TW%N_MAX
  CURR_FFTW_PLAN=>TW%FFTW_PLANS(JN)
  DO JL=1,TW%N_PLANS(JN)
    CALL DESTROY_PLAN_FFTW(CURR_FFTW_PLAN%NPLAN)
    CURR_FFTW_PLAN=>CURR_FFTW_PLAN%NEXT_PLAN 
  ENDDO
ENDDO
IF( ASSOCIATED(TW) ) THEN
  IF( ASSOCIATED(TW%FFTW_PLANS) )  DEALLOCATE(TW%FFTW_PLANS)
  IF( ALLOCATED(TW%N_PLANS) )     DEALLOCATE(TW%N_PLANS)
ENDIF
RETURN
END SUBROUTINE DESTROY_PLANS_FFTW

END MODULE TPM_FFTW
