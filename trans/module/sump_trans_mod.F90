MODULE SUMP_TRANS_MOD
CONTAINS
SUBROUTINE SUMP_TRANS

! Set up distributed environment for the transform package (part 2)

#include "tsmbkind.h"

USE TPM_GEN
USE TPM_DIM
USE TPM_GEOMETRY
USE TPM_DISTR

USE SUWAVEDI_MOD
USE PE2SET_MOD
USE SUMPLATF_MOD
USE SUMPLAT_MOD
USE SUSTAONL_MOD

IMPLICIT NONE

INTEGER_M :: JA,JJ,JM,JMLOC,ILATPP,IRESTL,IMLOC,IDT,INM
INTEGER_M :: JGL,IGL,IPLAT,J,ISENDSET,IRECVSET,JML,IPOS,IM
INTEGER_M :: I1,I2,I3,IAUX0,IAUX1,JA1
INTEGER_M :: IMYMS(R%NSMAX+1),INUMTPP(NPRTRW)
INTEGER_M :: IDUMI1,IDUMI2,IDUMI3
INTEGER_M :: IDUM2(0:R%NSMAX), IDUM3(NPRTRW+1), IDUM4(R%NSMAX+1)
INTEGER_M :: IC(NPRTRW)
INTEGER_M :: IGPTOT,IMEDIAP,IRESTM,JA,JB,IOFF
INTEGER_M :: IGPTOTL(NPRGPNS,NPRGPEW)

LOGICAL    :: LLP1,LLP2

INTEGER_M  :: MYSENDSET,MYRECVSET
!     ------------------------------------------------------------------


LLP1 = NPRINTLEV>0
LLP2 = NPRINTLEV>1
IF(LLP1) WRITE(NOUT,*) '=== ENTER ROUTINE SUMP_TRANS ==='

ALLOCATE(D%NULTPP(NPRTRNS))
IF(LLP2)WRITE(NOUT,9) 'D%NULTPP   ',SIZE(D%NULTPP   ),SHAPE(D%NULTPP   )
ALLOCATE(D%NPTRLS(NPRTRNS))
IF(LLP2)WRITE(NOUT,9) 'D%NPTRLS   ',SIZE(D%NPTRLS   ),SHAPE(D%NPTRLS   )
ALLOCATE(D%NPROCL(R%NDGL))
IF(LLP2)WRITE(NOUT,9) 'D%NPROCL   ',SIZE(D%NPROCL   ),SHAPE(D%NPROCL   )

CALL SUMPLATF(R%NDGL,NPRTRNS,MYSETW,D%NULTPP,D%NPROCL,D%NPTRLS)
D%NDGL_FS = D%NULTPP(MYSETW)

! pointer to the first wave number of a given wave-set in NALLMS array
ALLOCATE(D%NPTRMS(NPRTRW))
IF(LLP2)WRITE(NOUT,9) 'D%NPTRMS   ',SIZE(D%NPTRMS   ),SHAPE(D%NPTRMS   )
D%NPTRMS(:) = 1
DO JA=2,NPRTRW
  D%NPTRMS(JA) = D%NPTRMS(JA-1)+D%NUMPP(JA-1)
ENDDO

!  D%NALLMS :  wave numbers for all wave-set concatenated together to give all
!            wave numbers in wave-set order.
ALLOCATE(D%NALLMS(R%NSMAX+1))
IF(LLP2)WRITE(NOUT,9) 'D%NALLMS   ',SIZE(D%NALLMS   ),SHAPE(D%NALLMS   )

IC(:) = 0
DO JM=0,R%NSMAX
  D%NALLMS(IC(D%NPROCM(JM))+D%NPTRMS(D%NPROCM(JM))) = JM
  IC(D%NPROCM(JM)) = IC(D%NPROCM(JM))+1
ENDDO

ALLOCATE(D%NDIM0G(0:R%NSMAX))
IF(LLP2)WRITE(NOUT,9) 'D%NDIM0G   ',SIZE(D%NDIM0G   ),SHAPE(D%NDIM0G   )
IPOS = 1
DO JA=1,NPRTRW
  DO JMLOC=1,D%NUMPP(JA)
    IM = D%NALLMS(D%NPTRMS(JA)+JMLOC-1)
    D%NDIM0G(IM) = IPOS
    IPOS = IPOS+(R%NSMAX+1-IM)*2
  ENDDO
ENDDO

! Help arrays for spectral to fourier space transposition
ALLOCATE(D%NLTSGTB (NPRTRNS+1))
IF(LLP2)WRITE(NOUT,9) 'D%NLTSGTB ',SIZE(D%NLTSGTB),SHAPE(D%NLTSGTB)
ALLOCATE(D%NLTSFTB (NPRTRNS+1))
IF(LLP2)WRITE(NOUT,9) 'D%NLTSFTB ',SIZE(D%NLTSFTB),SHAPE(D%NLTSFTB)
ALLOCATE(D%NSTAGT0B(NPRTRNS+1))
IF(LLP2)WRITE(NOUT,9) 'D%NSTAGT0B ',SIZE(D%NSTAGT0B),SHAPE(D%NSTAGT0B)
ALLOCATE(D%NSTAGT1B(NPRTRNS+1))
IF(LLP2)WRITE(NOUT,9) 'D%NSTAGT1B ',SIZE(D%NSTAGT1B),SHAPE(D%NSTAGT1B)
ALLOCATE(D%MSTABF  (NPRTRNS+1))
IF(LLP2)WRITE(NOUT,9) 'D%MSTABF ',SIZE(D%MSTABF),SHAPE(D%MSTABF)

D%NLTSGTB(:) = 0
DO JGL=1,D%NDGL_FS
  IGL = D%NPTRLS(MYSETW)+JGL-1
  DO JM=0,G%NMEN(IGL)
    D%NLTSGTB(D%NPROCM(JM)) = D%NLTSGTB(D%NPROCM(JM))+1
  ENDDO
ENDDO
DO JA=1,NPRTRW
  IF (JA == MYSETW) THEN
    D%NLTSFTB(JA) = -9999
  ELSE
    IPLAT = 0
    DO JGL=1,D%NULTPP(JA)
      IGL = D%NPTRLS(JA)+JGL-1
      DO JM=1,D%NUMP
        IF(IGL > R%NDGNH-G%NDGLU(D%MYMS(JM)) .AND. IGL <= R%NDGNH+G%NDGLU(D%MYMS(JM))) THEN
          IPLAT = IPLAT + 1
        ENDIF
      ENDDO
    ENDDO
    D%NLTSFTB(JA) = IPLAT
  ENDIF
ENDDO

DO JA=1,NPRTRW-1
  ISENDSET = MYSENDSET(NPRTRW,MYSETW,JA)
  IRECVSET = MYRECVSET(NPRTRW,MYSETW,JA)
  D%MSTABF(IRECVSET) = ISENDSET
ENDDO
D%MSTABF(MYSETW) = MYSETW

ALLOCATE(D%NPNTGTB0(0:R%NSMAX,D%NDGL_FS))
IF(LLP2)WRITE(NOUT,9) 'D%NPNTGTB0 ',SIZE(D%NPNTGTB0 ),SHAPE(D%NPNTGTB0 )
ALLOCATE(D%NPNTGTB1(D%NUMP,R%NDGL))
IF(LLP2)WRITE(NOUT,9) 'D%NPNTGTB1 ',SIZE(D%NPNTGTB1 ),SHAPE(D%NPNTGTB1 )

DO JA=1,NPRTRW
  IPOS = 0
  DO JGL=1,D%NULTPP(MYSETW)
    IGL = D%NPTRLS(MYSETW) + JGL - 1
    DO JML=D%NPTRMS(JA),D%NPTRMS(JA)+D%NUMPP(JA)-1
      IM = D%NALLMS(JML)
      IF (IM  <=  G%NMEN(IGL)) THEN
        D%NPNTGTB0(IM,JGL) = IPOS
        IPOS = IPOS+1
      ELSE
        D%NPNTGTB0(IM,JGL) = -99
      ENDIF
    ENDDO
  ENDDO
ENDDO

DO JA=1,NPRTRW
  IPOS = 0
  DO JGL=1,D%NULTPP(JA)
    IGL = D%NPTRLS(JA) + JGL - 1
    DO JM=1,D%NUMP
      IM = D%MYMS(JM)
      IF (IM  <=  G%NMEN(IGL)) THEN
        D%NPNTGTB1(JM,IGL) = IPOS
        IPOS = IPOS+1
      ELSE
        D%NPNTGTB1(JM,IGL) = -99
      ENDIF
    ENDDO
  ENDDO
ENDDO

IAUX0 = 0
IAUX1 = 0
DO JA=1,NPRTRNS-1
  I1 = MYSENDSET(NPRTRNS,MYSETW,JA)
  I2 = MYRECVSET(NPRTRNS,MYSETW,JA)
  DO JA1=1,NPRTRNS-1
    IF(MYSENDSET(NPRTRNS,MYSETW,JA1) == I2) I3 =MYRECVSET(NPRTRNS,MYSETW,JA1)
  ENDDO
  IAUX0 = MAX(D%NLTSFTB(I1),D%NLTSGTB(I2),IAUX0)
  IAUX1 = MAX(D%NLTSGTB(I2),D%NLTSFTB(I3),IAUX1)
ENDDO
IAUX0 = MAX(D%NLTSGTB(MYSETW),IAUX0)
IAUX1 = MAX(D%NLTSGTB(MYSETW),IAUX1)
DO JA=1,NPRTRNS+1
  D%NSTAGT0B(JA) = (JA-1)*IAUX0
  D%NSTAGT1B(JA) = (JA-1)*IAUX1
ENDDO
D%NLENGT0B = IAUX0*NPRTRNS
D%NLENGT1B = IAUX1*NPRTRNS

! GRIDPOINT SPACE

ALLOCATE(D%NFRSTLAT(NPRGPNS))
IF(LLP2)WRITE(NOUT,9) 'D%NFRSTLAT ',SIZE(D%NFRSTLAT ),SHAPE(D%NFRSTLAT )
ALLOCATE(D%NLSTLAT(NPRGPNS))
IF(LLP2)WRITE(NOUT,9) 'D%NLSTLAT  ',SIZE(D%NLSTLAT  ),SHAPE(D%NLSTLAT  )
ALLOCATE(D%NPTRLAT(R%NDGL))
IF(LLP2)WRITE(NOUT,9) 'D%NPTRLAT  ',SIZE(D%NPTRLAT  ),SHAPE(D%NPTRLAT  )
ALLOCATE(D%NPTRFRSTLAT(NPRGPNS))
IF(LLP2)WRITE(NOUT,9) 'D%NPTRFRSTLAT',SIZE(D%NPTRFRSTLAT),SHAPE(D%NPTRFRSTLAT)
ALLOCATE(D%NPTRLSTLAT(NPRGPNS))
IF(LLP2)WRITE(NOUT,9)'D%NPTRLSTLAT',SIZE(D%NPTRLSTLAT),SHAPE(D%NPTRLSTLAT)
ALLOCATE(D%LSPLITLAT(R%NDGL))
IF(LLP2)WRITE(NOUT,9) 'D%LSPLITLAT',SIZE(D%LSPLITLAT),SHAPE(D%LSPLITLAT)



CALL SUMPLAT(R%NDGL,NPRGPNS,MYSETNS,D%LSPLIT,&
             &D%NFRSTLAT,D%NLSTLAT,D%NFRSTLOFF,D%NPTRLAT,&
             &D%NPTRFRSTLAT,D%NPTRLSTLAT,D%NPTRFLOFF,&
             &IMEDIAP,IRESTM,D%LSPLITLAT)

D%NDGL_GP = D%NLSTLAT(MYSETNS)-D%NFRSTLOFF

IF (LLP1) THEN
  WRITE(NOUT,FMT='(/'' OUTPUT FROM ROUTINE SUMPLAT: ''/)')
  WRITE(NOUT,FMT='('' D%NULTPP '')')
  WRITE(NOUT,FMT='(20(1X,I4))') D%NULTPP(1:NPRTRNS)
  WRITE(NOUT,FMT='('' D%NPROCL '')')
  WRITE(NOUT,FMT='(20(1X,I4))') D%NPROCL(1:R%NDGL)
  WRITE(NOUT,FMT='('' D%NFRSTLAT '')')
  WRITE(NOUT,FMT='(20(1X,I4))') D%NFRSTLAT(1:NPRGPNS)
  WRITE(NOUT,FMT='('' D%NLSTLAT '')')
  WRITE(NOUT,FMT='(20(1X,I4))') D%NLSTLAT(1:NPRGPNS)
  WRITE(NOUT,FMT='('' D%NFRSTLOFF  D%NPTRFLOFF '')')
  WRITE(NOUT,FMT='(2(1X,I6))') D%NFRSTLOFF, D%NPTRFLOFF
  WRITE(NOUT,FMT='('' D%NPTRLAT '')')
  WRITE(NOUT,FMT='(20(1X,I4))') D%NPTRLAT(1:R%NDGL)
  WRITE(NOUT,FMT='('' D%LSPLITLAT '')')
  WRITE(NOUT,FMT='(50(1X,L1))') D%LSPLITLAT(1:R%NDGL)
  WRITE(NOUT,FMT='('' D%NPTRFRSTLAT '')')
  WRITE(NOUT,FMT='(20(1X,I4))') D%NPTRFRSTLAT(1:NPRGPNS)
  WRITE(NOUT,FMT='('' D%NPTRLSTLAT '')')
  WRITE(NOUT,FMT='(20(1X,I4))') D%NPTRLSTLAT(1:NPRGPNS)
  WRITE(NOUT,FMT='(/)')
ENDIF
ALLOCATE(D%NSTA(R%NDGL+NPRGPNS-1,NPRGPEW))
IF(LLP2)WRITE(NOUT,9) 'D%NSTA     ',SIZE(D%NSTA     ),SHAPE(D%NSTA     )
ALLOCATE(D%NONL(R%NDGL+NPRGPNS-1,NPRGPEW))
IF(LLP2)WRITE(NOUT,9) 'D%NONL     ',SIZE(D%NONL     ),SHAPE(D%NONL     )

CALL SUSTAONL(IMEDIAP,IRESTM)

!  IGPTOTL is the number of grid points in each individual processor

DO JA=1,NPRGPNS
  DO JB=1,NPRGPEW
    IGPTOT = 0
    DO JGL=D%NPTRFRSTLAT(JA),D%NPTRLSTLAT(JA)
      IGPTOT = IGPTOT+D%NONL(JGL,JB)
    ENDDO
    IGPTOTL(JA,JB) = IGPTOT
  ENDDO
ENDDO
D%NGPTOT = IGPTOTL(MYSETNS,MYSETEW)
D%NGPTOTMX = MAXVAL(IGPTOTL)
D%NGPTOTG = SUM(IGPTOTL)

ALLOCATE(D%NSTAGTF(D%NDGL_FS))
IF(LLP2)WRITE(NOUT,9) 'D%NSTAGTF     ',SIZE(D%NSTAGTF ),SHAPE(D%NSTAGTF  )
IOFF = 0
DO JGL=1,D%NDGL_FS
  D%NSTAGTF(JGL) = IOFF
  IGL = D%NPTRLS(MYSETW) + JGL - 1
  IOFF = IOFF + G%NLOEN(IGL)+3
ENDDO
D%NLENGTF = IOFF

!     ------------------------------------------------------------------
9 FORMAT(1X,'ARRAY ',A10,' ALLOCATED ',8I8)

END SUBROUTINE SUMP_TRANS
END MODULE SUMP_TRANS_MOD


